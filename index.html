<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Option Move Calculator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      padding: 20px;
    }
    h1, h2 { color: #93c5fd; }
    .box {
      background: #020617;
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 6px;
    }
    label {
      display: block;
      margin-bottom: 8px;
    }
    input, select, button {
      width: 100%;
      padding: 6px;
      margin-top: 4px;
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #334155;
      border-radius: 4px;
      box-sizing: border-box;
    }
    button {
      margin-top: 10px;
      cursor: pointer;
    }
    #output {
      font-size: 1.1em;
      white-space: pre-line;
    }
    .hint {
      font-size: 0.9em;
      color: #94a3b8;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <h1>My Quant's Option Calculator</h1>

  <div class="box">
    <label>Underlying Price
      <input id="underlying" type="number" step="0.01" />
    </label>

    <label>Option Price (mid)
      <input id="optionPrice" type="number" step="0.01" />
    </label>

    <label>Delta
      <input id="delta" type="number" step="0.0001" />
    </label>

    <label>Gamma
      <input id="gamma" type="number" step="0.0001" />
    </label>

    <label>Theta (per day)
      <input id="theta" type="number" step="0.0001" />
    </label>

    <label>Vega (per +1.00 IV point)
      <input id="vega" type="number" step="0.0001" value="0" />
      <div class="hint">Example: if IV +1.0 (one vol point) adds ~$0.08 to the option, vega = 0.08</div>
    </label>

    <label>Expected IV Change over horizon (IV points)
      <input id="dIv" type="number" step="0.01" value="0" />
      <div class="hint">Example: IV goes 18.5 → 20.0, ΔIV = +1.5</div>
    </label>
  </div>

  <div class="box">
    <h2>Target</h2>

    <label>Target Option Price
      <input id="targetPrice" type="number" step="0.01" />
    </label>

    <label>Time Horizon
      <select id="timeHorizon">
        <option value="0">Now</option>
        <option value="1">1 day</option>
        <option value="2">2 days</option>
        <option value="3">3 days</option>
        <option value="4">4 days</option>
        <option value="5">5 days</option>
      </select>
    </label>

    <button id="calculate">Calculate Required Move</button>
  </div>

  <div class="box" id="output"></div>

  <script>
    function clamp(x, lo, hi) {
      return Math.max(lo, Math.min(hi, x));
    }

    // Estimate-only solver that lets Greeks drift as price moves.
    // Adds a simple IV term: vega * dIV (user-supplied), applied evenly over steps.
    function solveMoveWithGreekDrift({
      optionPrice,
      targetPrice,
      delta0,
      gamma0,
      theta0,
      vega0,
      dIvTotal,
      timeDays
    }) {
      const steps = 80;
      const gammaFloor = 1e-6;
      const baseShape = Math.max(0.01, Math.abs(delta0) * (1 - Math.abs(delta0)));

      function simulate(dx) {
        let price = optionPrice;
        let d = delta0;
        let g = gamma0;
        let th = theta0;

        // Keep vega simple but not insane: scale with sqrt(time remaining proxy)
        // If you want "pure constant vega", replace this with: let v = vega0;
        let v = vega0;

        const step = dx / steps;
        const dt = timeDays / steps;
        const dIvStep = dIvTotal / steps;

        for (let i = 0; i < steps; i++) {
          // Price change: delta/gamma/theta + vega*dIV
          price += d * step + 0.5 * g * step * step + th * dt + v * dIvStep;

          // Delta drift from gamma
          d = clamp(d + g * step, -1, 1);

          // Gamma shape drift (your heuristic)
          const shape = Math.max(0.01, Math.abs(d) * (1 - Math.abs(d)));
          g = Math.max(gammaFloor, gamma0 * (shape / baseShape));

          // Theta drift heuristic (your existing choice)
          th = theta0 * (g / gamma0);

          // Optional: vega drift (very rough). Comment out if you want constant vega.
          // Vega tends to be highest near ATM; we loosely tie it to the same shape factor:
          v = vega0 * (shape / baseShape);
        }

        return { price, delta: d, gamma: g, theta: th, vega: v };
      }

      // Bracket dx so f(lo) and f(hi) straddle target
      let lo = -200, hi = 200;
      function f(x) { return simulate(x).price - targetPrice; }

      let flo = f(lo), fhi = f(hi), tries = 0;
      while (flo * fhi > 0 && tries < 10) {
        lo *= 1.6; hi *= 1.6;
        flo = f(lo); fhi = f(hi);
        tries++;
      }
      if (flo * fhi > 0) return null;

      // Binary search
      for (let i = 0; i < 60; i++) {
        const mid = (lo + hi) / 2;
        const fmid = f(mid);

        if (Math.abs(fmid) < 1e-6) {
          const res = simulate(mid);
          return { move: mid, ...res };
        }

        if (flo * fmid <= 0) { hi = mid; fhi = fmid; }
        else { lo = mid; flo = fmid; }
      }

      const finalMove = (lo + hi) / 2;
      return { move: finalMove, ...simulate(finalMove) };
    }

    // Frozen-Greeks minimum reachable price (convex limit) for gamma>0
    function frozenGreeksMin(optionPrice, delta, gamma, theta, vega, dIv, timeDays) {
      const a = 0.5 * gamma;
      if (Math.abs(a) < 1e-12) return null;

      const dxStar = -delta / (2 * a);
      const minChange = delta * dxStar + a * dxStar * dxStar + theta * timeDays + vega * dIv;
      return { dxStar, minPrice: optionPrice + minChange };
    }

    // Frozen-Greeks quadratic solve with IV term
    function requiredStockMove({ optionPrice, targetPrice, delta, gamma, theta, vega, dIv, timeDays }) {
      const dC = targetPrice - optionPrice;

      const a = 0.5 * gamma;
      const b = delta;

      // delta*dx + 0.5*gamma*dx^2 + theta*t + vega*dIV = dC
      const c = theta * timeDays + vega * dIv - dC;

      // Linear fallback if gamma ~ 0
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) return null;
        return -c / b;
      }

      const disc = b * b - 4 * a * c;
      if (disc < 0) return null;

      const s = Math.sqrt(disc);
      const r1 = (-b + s) / (2 * a);
      const r2 = (-b - s) / (2 * a);
      return Math.abs(r1) < Math.abs(r2) ? r1 : r2;
    }

    const calcBtn = document.getElementById('calculate');
    const output = document.getElementById('output');

    calcBtn.onclick = () => {
      const underlyingVal  = parseFloat(document.getElementById('underlying').value);
      const optionPriceVal = parseFloat(document.getElementById('optionPrice').value);
      const targetPriceVal = parseFloat(document.getElementById('targetPrice').value);
      const deltaVal       = parseFloat(document.getElementById('delta').value);
      const gammaVal       = parseFloat(document.getElementById('gamma').value);
      const thetaVal       = parseFloat(document.getElementById('theta').value);
      const vegaVal        = parseFloat(document.getElementById('vega').value);
      const dIvVal         = parseFloat(document.getElementById('dIv').value);
      const timeDaysVal    = parseFloat(document.getElementById('timeHorizon').value);

      if ([underlyingVal, optionPriceVal, targetPriceVal, deltaVal, gammaVal, thetaVal, vegaVal, dIvVal, timeDaysVal].some(isNaN)) {
        output.textContent = "Please fill in all fields.";
        return;
      }

      const move = requiredStockMove({
        optionPrice: optionPriceVal,
        targetPrice: targetPriceVal,
        delta: deltaVal,
        gamma: gammaVal,
        theta: thetaVal,
        vega: vegaVal,
        dIv: dIvVal,
        timeDays: timeDaysVal
      });

      // If frozen-greeks fails, use drift estimate
      if (move === null) {
        const est = solveMoveWithGreekDrift({
          optionPrice: optionPriceVal,
          targetPrice: targetPriceVal,
          delta0: deltaVal,
          gamma0: gammaVal,
          theta0: thetaVal,
          vega0: vegaVal,
          dIvTotal: dIvVal,
          timeDays: timeDaysVal
        });

        if (!est) {
          const lim = frozenGreeksMin(optionPriceVal, deltaVal, gammaVal, thetaVal, vegaVal, dIvVal, timeDaysVal);
          output.textContent = lim
            ? `Closest estimate:\nUnderlying ≈ ${(underlyingVal + lim.dxStar).toFixed(2)}\nOption ≈ ${lim.minPrice.toFixed(2)}`
            : "No estimate available.";
          return;
        }

        output.textContent =
          `Estimated underlying price: ${(underlyingVal + est.move).toFixed(2)}\n` +
          `Estimated underlying move: ${est.move.toFixed(2)}\n\n` +
          `Estimated Greeks:\n` +
          `• Delta ≈ ${est.delta.toFixed(4)}\n` +
          `• Gamma ≈ ${est.gamma.toFixed(6)}\n` +
          `• Theta/day ≈ ${est.theta.toFixed(4)}\n` +
          `• Vega/IV-pt ≈ ${est.vega.toFixed(4)}\n\n` +
          `IV assumption:\n` +
          `• ΔIV over horizon = ${dIvVal.toFixed(2)}\n\n` +
          `Note: Still an estimate (skew/vol surface not modeled).`;
        return;
      }

      // Frozen-greeks success path
      output.textContent =
        `Required underlying move: ${move.toFixed(2)}\n` +
        `Target underlying price: ${(underlyingVal + move).toFixed(2)}\n\n` +
        `Included:\n` +
        `• Theta over ${timeDaysVal} day(s)\n` +
        `• Vega × ΔIV (${vegaVal.toFixed(4)} × ${dIvVal.toFixed(2)})\n\n` +
        `Assumptions:\n` +
        `• Greeks locally valid\n` +
        `• ΔIV is your manual input\n` +
        `• Best for small–moderate moves`;
    };
  </script>
</body>
</html>
