<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Option Move Calculator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      padding: 20px;
    }
    h1, h2 { color: #93c5fd; }
    .box {
      background: #020617;
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 6px;
    }
    label {
      display: block;
      margin-bottom: 8px;
    }
    input, select, button {
      width: 100%;
      padding: 6px;
      margin-top: 4px;
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #334155;
      border-radius: 4px;
      box-sizing: border-box;
    }
    button {
      margin-top: 10px;
      cursor: pointer;
    }
    #output {
      font-size: 1.1em;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>My Quant's Option Calculator</h1>

  <div class="box">
    <label>Underlying Price
      <input id="underlying" type="number" step="0.01" value="690.31" />
    </label>

    <label>Option Price (mid)
      <input id="optionPrice" type="number" step="0.01" value="1.90" />
    </label>

    <label>Delta
      <input id="delta" type="number" step="0.0001" value="0.45" />
    </label>

    <label>Gamma
      <input id="gamma" type="number" step="0.0001" value="0.07" />
    </label>

    <label>Theta (per day)
      <input id="theta" type="number" step="0.0001" value="-0.23" />
    </label>
  </div>

  <div class="box">
    <h2>Target</h2>

    <label>Target Option Price
      <input id="targetPrice" type="number" step="0.01" value="0.30" />
    </label>

    <label>Time Horizon
      <select id="timeHorizon">
        <option value="0">Now</option>
        <option value="1">1 day</option>
        <option value="2">2 days</option>
        <option value="3">3 days</option>
        <option value="4">4 days</option>
        <option value="5">5 days</option>
      </select>
    </label>

    <button id="calculate">Calculate Required Move</button>
  </div>

  <div class="box" id="output"></div>

  <script>
    function clamp(x, lo, hi) {
      return Math.max(lo, Math.min(hi, x));
    }

    // Estimate-only solver that lets Greeks drift as price moves.
    // This is NOT a real option model; it’s a practical heuristic.
    function solveMoveWithGreekDrift({
      optionPrice,
      targetPrice,
      delta0,
      gamma0,
      theta0,
      timeDays
    }) {
      const steps = 80;
      const gammaFloor = 1e-6;

      const baseShape = Math.max(0.01, Math.abs(delta0) * (1 - Math.abs(delta0)));

      function simulate(dx) {
        let price = optionPrice;
        let d = delta0;
        let g = gamma0;
        let th = theta0;

        const step = dx / steps;
        const dt = timeDays / steps;

        for (let i = 0; i < steps; i++) {
          // Price update
          price += d * step + 0.5 * g * step * step + th * dt;

          // Delta drifts by gamma
          d = clamp(d + g * step, -1, 1);

          // Gamma decays as |delta| moves toward 0 or 1 (OTM/ITM)
          const shape = Math.max(0.01, Math.abs(d) * (1 - Math.abs(d)));
          g = Math.max(gammaFloor, gamma0 * (shape / baseShape));

          // Theta magnitude decays with gamma (rough)
          th = theta0 * (g / gamma0);
        }

        return { price, delta: d, gamma: g, theta: th };
      }

      // Bracket dx so f(lo) and f(hi) straddle target
      let lo = -200, hi = 200;

      function f(x) {
        return simulate(x).price - targetPrice;
      }

      let flo = f(lo), fhi = f(hi);
      let tries = 0;
      while (flo * fhi > 0 && tries < 10) {
        lo *= 1.6;
        hi *= 1.6;
        flo = f(lo);
        fhi = f(hi);
        tries++;
      }
      if (flo * fhi > 0) return null;

      // Binary search
      for (let i = 0; i < 60; i++) {
        const mid = (lo + hi) / 2;
        const fmid = f(mid);

        if (Math.abs(fmid) < 1e-6) {
          const res = simulate(mid);
          return { move: mid, ...res };
        }

        if (flo * fmid <= 0) {
          hi = mid;
          fhi = fmid;
        } else {
          lo = mid;
          flo = fmid;
        }
      }

      const finalMove = (lo + hi) / 2;
      const res = simulate(finalMove);
      return { move: finalMove, ...res };
    }

    // Frozen-Greeks minimum reachable price (convex limit) for gamma>0
    function frozenGreeksMin(optionPrice, delta, gamma, theta, timeDays) {
      const a = 0.5 * gamma;
      const b = delta;

      if (Math.abs(a) < 1e-12) return null;

      const dxStar = -b / (2 * a);
      const minChange = (b * dxStar) + (a * dxStar * dxStar) + (theta * timeDays);
      const minPrice = optionPrice + minChange;

      return { dxStar, minPrice, minChange };
    }

    // Frozen-Greeks quadratic solve
    function requiredStockMove({ optionPrice, targetPrice, delta, gamma, theta, timeDays }) {
      const dC = targetPrice - optionPrice;

      const a = 0.5 * gamma;
      const b = delta;
      const c = theta * timeDays - dC;

      // Linear fallback if gamma ~ 0
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) return null;
        return -c / b;
      }

      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) return null;

      const sqrtD = Math.sqrt(discriminant);
      const root1 = (-b + sqrtD) / (2 * a);
      const root2 = (-b - sqrtD) / (2 * a);

      return Math.abs(root1) < Math.abs(root2) ? root1 : root2;
    }

    const calcBtn = document.getElementById('calculate');
    const output = document.getElementById('output');

    calcBtn.onclick = () => {
      const underlying  = parseFloat(document.getElementById('underlying').value);
      const optionPrice = parseFloat(document.getElementById('optionPrice').value);
      const targetPrice = parseFloat(document.getElementById('targetPrice').value);
      const delta       = parseFloat(document.getElementById('delta').value);
      const gamma       = parseFloat(document.getElementById('gamma').value);
      const theta       = parseFloat(document.getElementById('theta').value);
      const timeDays    = parseFloat(document.getElementById('timeHorizon').value);

      if (
        isNaN(underlying) ||
        isNaN(optionPrice) ||
        isNaN(targetPrice) ||
        isNaN(delta) ||
        isNaN(gamma) ||
        isNaN(theta) ||
        isNaN(timeDays)
      ) {
        output.textContent = "Please fill in all fields.";
        return;
      }

      // First try frozen-greeks solution
      const move = requiredStockMove({
        optionPrice,
        targetPrice,
        delta,
        gamma,
        theta,
        timeDays
      });

      // If frozen-greeks fails, use drift estimate (your requested behavior)
      if (move === null) {
        const est = solveMoveWithGreekDrift({
          optionPrice,
          targetPrice,
          delta0: delta,
          gamma0: gamma,
          theta0: theta,
          timeDays
        });

        if (!est) {
          // Last fallback: show frozen-greeks minimum reachable level
          const lim = frozenGreeksMin(optionPrice, delta, gamma, theta, timeDays);
          if (lim) {
            const limitUnderlying = underlying + lim.dxStar;
            output.textContent =
              `Target not reachable with current Greeks.\n\n` +
              `Closest frozen-Greeks estimate:\n` +
              `• Underlying ≈ ${limitUnderlying.toFixed(2)} (move ${lim.dxStar.toFixed(2)})\n` +
              `• Option ≈ ${lim.minPrice.toFixed(2)}\n\n` +
              `Try 1+ day horizon, or updated Greeks.`;
          } else {
            output.textContent =
              "No estimate available. Try longer time horizon or updated Greeks.";
          }
          return;
        }

        const targetStock = underlying + est.move;

        output.textContent =
          `Estimated underlying price needed: ${targetStock.toFixed(2)}\n` +
          `Estimated underlying move: ${est.move.toFixed(2)}\n\n` +
          `Estimated Greeks at that level:\n` +
          `• Delta ≈ ${est.delta.toFixed(4)}\n` +
          `• Gamma ≈ ${est.gamma.toFixed(6)}\n` +
          `• Theta/day ≈ ${est.theta.toFixed(4)}\n\n` +
          `Note: Estimated (IV not modeled).`;
        return;
      }

      // Frozen-greeks success path
      const targetStock = underlying + move;

      output.textContent =
        `Required underlying move: ${move.toFixed(2)}\n` +
        `Target underlying price: ${targetStock.toFixed(2)}\n\n` +
        `Assumptions:\n` +
        `• IV flat\n` +
        `• Greeks locally valid\n` +
        `• Small–moderate move only`;
    };
  </script>
</body>
</html>
