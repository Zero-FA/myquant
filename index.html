<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Option Move Calculator</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #0f172a;
      color: #e5e7eb;
      padding: 20px;
    }

    h1, h2 { color: #93c5fd; }

    .box {
      background: #020617;
      padding: 15px;
      margin-bottom: 15px;
      border-radius: 6px;
    }

    label {
      display: block;
      margin-bottom: 8px;
    }

    input, select, button {
      width: 100%;
      padding: 6px;
      margin-top: 4px;
      background: #020617;
      color: #e5e7eb;
      border: 1px solid #334155;
      border-radius: 4px;
      box-sizing: border-box;
    }

    button {
      margin-top: 10px;
      cursor: pointer;
    }

    #output {
      font-size: 1.1em;
      white-space: pre-line;
    }
  </style>
</head>
<body>
  <h1>My Quant's Option Calculator</h1>

  <div class="box">
    <label>Underlying Price
      <input id="underlying" type="number" step="0.01" />
    </label>

    <label>Option Price (mid)
      <input id="optionPrice" type="number" step="0.01" />
    </label>

    <label>Delta
      <input id="delta" type="number" step="0.0001" />
    </label>

    <label>Gamma
      <input id="gamma" type="number" step="0.0001" />
    </label>

    <label>Theta (per day)
      <input id="theta" type="number" step="0.0001" />
    </label>
  </div>

  <div class="box">
    <h2>Target</h2>

    <label>Target Option Price
      <input id="targetPrice" type="number" step="0.01" />
    </label>

    <label>Time Horizon
      <select id="timeHorizon">
        <option value="0">Now</option>
        <option value="1">1 day</option>
        <option value="2">2 days</option>
        <option value="3">3 days</option>
        <option value="4">4 days</option>
        <option value="5">5 days</option>
      </select>
    </label>

    <button id="calculate">Calculate Required Move</button>
  </div>

  <div class="box" id="output"></div>

  <script>
    function clamp(x, lo, hi) {
  return Math.max(lo, Math.min(hi, x));
}

// Heuristic "greeks drift" simulator + binary search to hit targetPrice.
// Not a real pricing model — just a practical estimate.
function solveMoveWithGreekDrift({
  optionPrice,
  targetPrice,
  underlying,
  delta0,
  gamma0,
  theta0,
  timeDays
}) {
  const steps = 60;
  const gammaFloor = 1e-6;

  // For scaling gamma as delta collapses: use |delta| in [0,1]
  const baseShape = Math.max(0.01, Math.abs(delta0) * (1 - Math.abs(delta0)));

  function simulate(dx) {
    let price = optionPrice;
    let d = delta0;
    let g = gamma0;
    let th = theta0;

    const step = dx / steps;
    const dt = timeDays / steps;

    for (let i = 0; i < steps; i++) {
      // Update price using local delta/gamma + theta
      price += d * step + 0.5 * g * step * step + th * dt;

      // Drift delta by gamma
      d = d + g * step;
      d = clamp(d, -1, 1);

      // Decay gamma as option goes more OTM/ITM (shape collapses near |delta|=0 or 1)
      const shape = Math.max(0.01, Math.abs(d) * (1 - Math.abs(d)));
      g = gamma0 * (shape / baseShape);
      g = Math.max(gammaFloor, g);

      // Theta tends to decay as gamma collapses (very rough)
      th = theta0 * (g / gamma0);
    }

    return { price, delta: d, gamma: g, theta: th };
  }

  // Binary search bounds for dx
  // Start with a reasonable bracket and expand until target is between.
  let lo = -50, hi = 50;

  const wantUp = targetPrice > optionPrice; // if we need option to rise

  function okBracket(a, b) {
    // we want f(lo) and f(hi) to straddle target
    const fa = simulate(a).price - targetPrice;
    const fb = simulate(b).price - targetPrice;
    return fa === 0 || fb === 0 || (fa < 0 && fb > 0) || (fa > 0 && fb < 0);
  }

  // Expand bracket up to a limit
  let tries = 0;
  while (!okBracket(lo, hi) && tries < 12) {
    lo *= 1.6;
    hi *= 1.6;
    tries++;
  }

  if (!okBracket(lo, hi)) {
    return null; // still couldn't bracket target
  }

  // Binary search
  for (let i = 0; i < 50; i++) {
    const mid = (lo + hi) / 2;
    const pmid = simulate(mid).price;

    if (pmid === targetPrice) {
      const res = simulate(mid);
      return { move: mid, ...res };
    }

    // Decide which side keeps the bracket
    const flo = simulate(lo).price - targetPrice;
    const fmid = pmid - targetPrice;

    if ((flo < 0 && fmid < 0) || (flo > 0 && fmid > 0)) {
      lo = mid;
    } else {
      hi = mid;
    }
  }

  const finalMove = (lo + hi) / 2;
  const res = simulate(finalMove);
  return { move: finalMove, ...res };
}
    function requiredStockMove({ optionPrice, targetPrice, delta, gamma, theta, timeDays }) {
      const dC = targetPrice - optionPrice;

      const a = 0.5 * gamma;
      const b = delta;
      const c = theta * timeDays - dC;

      // Linear fallback if gamma is ~0
      if (Math.abs(a) < 1e-12) {
        if (Math.abs(b) < 1e-12) return null;
        return -c / b;
      }

      const discriminant = b * b - 4 * a * c;
      if (discriminant < 0) return null;

      const sqrtD = Math.sqrt(discriminant);
      const root1 = (-b + sqrtD) / (2 * a);
      const root2 = (-b - sqrtD) / (2 * a);

      return Math.abs(root1) < Math.abs(root2) ? root1 : root2;
    }

    const calcBtn = document.getElementById('calculate');
    const output = document.getElementById('output');

    calcBtn.onclick = () => {
      const underlying  = parseFloat(document.getElementById('underlying').value);
      const optionPrice = parseFloat(document.getElementById('optionPrice').value);
      const targetPrice = parseFloat(document.getElementById('targetPrice').value);
      const delta       = parseFloat(document.getElementById('delta').value);
      const gamma       = parseFloat(document.getElementById('gamma').value);
      const theta       = parseFloat(document.getElementById('theta').value);
      const timeDays    = parseFloat(document.getElementById('timeHorizon').value);

      if (
        isNaN(underlying) ||
        isNaN(optionPrice) ||
        isNaN(targetPrice) ||
        isNaN(delta) ||
        isNaN(gamma) ||
        isNaN(theta) ||
        isNaN(timeDays)
      ) {
        output.textContent = "Please fill in all fields.";
        return;
      }

      const move = requiredStockMove({
        optionPrice,
        targetPrice,
        delta,
        gamma,
        theta,
        timeDays
      });

if (move === null) {
  // Try heuristic greeks-drift estimate
  const est = solveMoveWithGreekDrift({
    optionPrice,
    targetPrice,
    underlying,
    delta0: delta,
    gamma0: gamma,
    theta0: theta,
    timeDays
  });

  if (!est) {
    output.textContent =
      "No solution found (even with estimated Greeks drift).\n" +
      "Try a smaller target change, longer time horizon, or updated Greeks.";
    return;
  }

  const targetStock = underlying + est.move;

  output.textContent =
    `Estimated required underlying price: ${targetStock.toFixed(2)}\n` +
    `Estimated underlying move: ${est.move.toFixed(2)}\n\n` +
    `Estimated Greeks at that level:\n` +
    `• Delta ≈ ${est.delta.toFixed(4)}\n` +
    `• Gamma ≈ ${est.gamma.toFixed(6)}\n` +
    `• Theta/day ≈ ${est.theta.toFixed(4)}\n\n` +
    `Note: Greeks are estimated (IV not modeled).`;
  return;
}

      const targetStock = underlying + move;

      output.textContent =
        `Required underlying move: ${move.toFixed(2)}\n` +
        `Target underlying price: ${targetStock.toFixed(2)}\n\n` +
        `Assumptions:\n` +
        `• IV flat\n` +
        `• Greeks locally valid\n` +
        `• Small–moderate move only`;
    };
  </script>
</body>
</html>
